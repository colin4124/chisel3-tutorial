* 搭建开发环境
** 安装 scratchip
#+begin_src bash
pip3 install scratchip
#+end_src

** 使用 scratchip 创建开发环境
#+begin_src bash
  scratchip create foo
  cd foo
  make verilog
#+end_src

生成的 ~verilog~ 放在 ~builds/~ 目录下。

* 简单的例子：二选一多路选择器

#+begin_src scala
class Top extends RawModule {
  val sel = IO(Input(UInt(1.W)))
  val in0 = IO(Input(UInt(1.W)))
  val in1 = IO(Input(UInt(1.W)))
  val out = IO(Output(UInt(1.W)))

  out := sel & in1 | ~sel & in0
}
#+end_src

#+begin_src verilog
module Top(
  input   sel,
  input   in0,
  input   in1,
  output  out
);
  assign out = sel & in1 | ~sel & in0;
endmodule
#+end_src

* 基本数据类型

* 定义模块

** 默认提供时钟域的模块

*** 不带复位
#+begin_src scala
  class Top extends Module {
  val sel = IO(Input(UInt(1.W)))
  val in0 = IO(Input(UInt(1.W)))
  val in1 = IO(Input(UInt(1.W)))
  val out = IO(Output(UInt(1.W)))

  val inner = Reg(Bool())
  inner := sel & in1 | ~sel & in0
  out := inner
}
#+end_src

#+begin_src verilog
module Top(
  input   clock,
  input   reset,
  input   sel,
  input   in0,
  input   in1,
  output  out
);
  reg  inner;
  assign out = inner;
  always @(posedge clock) begin
    inner <= sel & in1 | ~sel & in0;
  end
endmodule
#+end_src

*** 带复位

#+begin_src scala
class Top extends Module {
  val sel = IO(Input(UInt(1.W)))
  val in0 = IO(Input(UInt(1.W)))
  val in1 = IO(Input(UInt(1.W)))
  val out = IO(Output(UInt(1.W)))

  val inner = Reg(0.B)
  inner := sel & in1 | ~sel & in0
  out := inner
}
#+end_src

#+begin_src verilog
module Top(
  input   clock,
  input   reset,
  input   sel,
  input   in0,
  input   in1,
  output  out
);
  reg  inner;
  assign out = inner;
  always @(posedge clock) begin
    if (reset) begin
      inner <= 1'h0;
    end else begin
      inner <= sel & in1 | ~sel & in0;
    end
  end
endmodule
#+end_src

** 自定义时钟域的模块

*** 同步复位

#+begin_src scala
class Top extends RawModule {
  val my_clk = IO(Input(Clock()))
  val my_rst = IO(Input(Bool()))

  val sel = IO(Input(UInt(1.W)))
  val in0 = IO(Input(UInt(1.W)))
  val in1 = IO(Input(UInt(1.W)))
  val out = IO(Output(UInt(1.W)))

  val inner = withClockAndReset(my_clk, my_rst) { RegInit(0.B) }
  inner := sel & in1 | ~sel & in0
  out := inner
}
#+end_src

#+begin_src verilog
  module Top(
  input   my_clk,
  input   my_rst,
  input   sel,
  input   in0,
  input   in1,
  output  out
);
  reg  inner;
  assign out = inner;
  always @(posedge my_clk) begin
    if (my_rst) begin
      inner <= 1'h0;
    end else begin
      inner <= sel & in1 | ~sel & in0;
    end
  end
endmodule
#+end_src

*** 异步复位
#+begin_src scala
class Top extends RawModule {
  val my_clk = IO(Input(Clock()))
  val my_rst = IO(Input(AsyncReset()))

  val sel = IO(Input(UInt(1.W)))
  val in0 = IO(Input(UInt(1.W)))
  val in1 = IO(Input(UInt(1.W)))
  val out = IO(Output(UInt(1.W)))

  val inner = withClockAndReset(my_clk, my_rst) { RegInit(0.B) }
  inner := sel & in1 | ~sel & in0
  out := inner
}
#+end_src

#+begin_src verilog
module Top(
  input   my_clk,
  input   my_rst,
  input   sel,
  input   in0,
  input   in1,
  output  out
);
  reg  inner;
  assign out = inner;
  always @(posedge my_clk or posedge my_rst) begin
    if (my_rst) begin
      inner <= 1'h0;
    end else begin
      inner <= sel & in1 | ~sel & in0;
    end
  end
endmodule
#+end_src

** 引用外部写好的模块

#+begin_src scala
class Foo extends ExtModule {
  val sel = IO(Input(UInt(1.W)))
  val in0 = IO(Input(UInt(1.W)))
  val in1 = IO(Input(UInt(1.W)))
  val out = IO(Output(UInt(1.W)))

}

class Top extends RawModule {
  val sel = IO(Input(UInt(1.W)))
  val in0 = IO(Input(UInt(1.W)))
  val in1 = IO(Input(UInt(1.W)))
  val out = IO(Output(UInt(1.W)))

  val u_foo = Module(new Foo)

  sel <> u_foo.sel
  in0 <> u_foo.in0
  in1 <> u_foo.in1
  out <> u_foo.out
}
#+end_src

#+begin_src verilog
module Top(
  input   sel,
  input   in0,
  input   in1,
  output  out
);
  wire  u_foo_sel;
  wire  u_foo_in0;
  wire  u_foo_in1;
  wire  u_foo_out;
  Foo u_foo (
    .sel(u_foo_sel),
    .in0(u_foo_in0),
    .in1(u_foo_in1),
    .out(u_foo_out)
  );
  assign out = u_foo_out;
  assign u_foo_sel = sel;
  assign u_foo_in0 = in0;
  assign u_foo_in1 = in1;
endmodule
#+end_src

* 模块层级

#+begin_src scala
class A extends ExtModule {
  val in0 = IO(Input(UInt(1.W)))
  val in1 = IO(Input(UInt(1.W)))
  val out = IO(Output(UInt(1.W)))
}

class B extends ExtModule {
  val in0 = IO(Input(UInt(1.W)))
  val in1 = IO(Input(UInt(1.W)))
  val out = IO(Output(UInt(1.W)))
}

class Top extends RawModule {
  val in0 = IO(Input(UInt(1.W)))
  val in1 = IO(Input(UInt(1.W)))
  val out = IO(Output(UInt(1.W)))

  val u_a = Module(new A)
  val u_b = Module(new B)

  u_a.in0 := in0
  u_a.in1 := in1

  u_b.in0 := in0
  u_b.in1 := in1

  out := u_a.out | u_b.out
}
#+end_src

#+begin_src verilog
module Top(
  input   in0,
  input   in1,
  output  out
);
  wire  u_a_in0;
  wire  u_a_in1;
  wire  u_a_out;
  wire  u_b_in0;
  wire  u_b_in1;
  wire  u_b_out;
  A u_a (
    .in0(u_a_in0),
    .in1(u_a_in1),
    .out(u_a_out)
  );
  B u_b (
    .in0(u_b_in0),
    .in1(u_b_in1),
    .out(u_b_out)
  );
  assign out = u_a_out | u_b_out;
  assign u_a_in0 = in0;
  assign u_a_in1 = in1;
  assign u_b_in0 = in0;
  assign u_b_in1 = in1;
endmodule
#+end_src

* 集合类数据类型

* 条件判断
** Mux
#+begin_src scala
class Top extends RawModule {
  val sel = IO(Input(Bool()))
  val in0 = IO(Input(UInt(1.W)))
  val in1 = IO(Input(UInt(1.W)))
  val out = IO(Output(UInt(1.W)))

  out := Mux(sel, in0, in1)
}
#+end_src

#+begin_src verilog
module Top(
  input   sel,
  input   in0,
  input   in1,
  output  out
);
  assign out = sel ? in0 : in1;
endmodule
#+end_src
** MuxCase
#+begin_src scala
  class Top extends RawModule {
    val sel = IO(Input(UInt(2.W)))
    val in = IO(Input(UInt(4.W)))
    val out = IO(Output(UInt(1.W)))

    out := MuxCase(0.B, Seq(
      (sel === 0.U) -> in(0),
      (sel === 1.U) -> in(1),
      (sel === 2.U) -> in(2),
      (sel === 3.U) -> in(3),
    ))
  }
#+end_src

#+begin_src verilog
module Top(
  input  [1:0] sel,
  input  [3:0] in,
  output       out
);
  wire  _out_T = sel == 2'h0;
  wire  _out_T_2 = sel == 2'h1;
  wire  _out_T_4 = sel == 2'h2;
  wire  _out_T_6 = sel == 2'h3;
  wire  _out_T_9 = _out_T_4 ? in[2] : _out_T_6 & in[3];
  wire  _out_T_10 = _out_T_2 ? in[1] : _out_T_9;
  assign out = _out_T ? in[0] : _out_T_10;
endmodule
#+end_src
** When
** Switch
